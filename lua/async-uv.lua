local a = require("async")
return {
	accept = vim.loop.accept,
	async_send = vim.loop.async_send,
	available_parallelism = vim.loop.available_parallelism,
	backend_fd = vim.loop.backend_fd,
	backend_timeout = vim.loop.backend_timeout,
	cancel = vim.loop.cancel,
	chdir = vim.loop.chdir,
	check_start = a.wrap(vim.loop.check_start),
	check_stop = vim.loop.check_stop,
	close = a.wrap(vim.loop.close),
	constants = vim.loop.constants,
	cpu_info = vim.loop.cpu_info,
	cwd = vim.loop.cwd,
	disable_stdio_inheritance = vim.loop.disable_stdio_inheritance,
	exepath = vim.loop.exepath,
	fileno = vim.loop.fileno,
	fs_access = a.wrap(vim.loop.fs_access),
	fs_chmod = a.wrap(vim.loop.fs_chmod),
	fs_chown = a.wrap(vim.loop.fs_chown),
	fs_close = a.wrap(vim.loop.fs_close),
	fs_closedir = a.wrap(vim.loop.fs_closedir),
	fs_copyfile = a.wrap(vim.loop.fs_copyfile),
	fs_event_getpath = vim.loop.fs_event_getpath,
	fs_event_start = a.wrap(vim.loop.fs_event_start),
	fs_event_stop = vim.loop.fs_event_stop,
	fs_fchmod = a.wrap(vim.loop.fs_fchmod),
	fs_fchown = a.wrap(vim.loop.fs_fchown),
	fs_fdatasync = a.wrap(vim.loop.fs_fdatasync),
	fs_fstat = a.wrap(vim.loop.fs_fstat),
	fs_fsync = a.wrap(vim.loop.fs_fsync),
	fs_ftruncate = a.wrap(vim.loop.fs_ftruncate),
	fs_futime = a.wrap(vim.loop.fs_futime),
	fs_lchown = a.wrap(vim.loop.fs_lchown),
	fs_link = a.wrap(vim.loop.fs_link),
	fs_lstat = a.wrap(vim.loop.fs_lstat),
	fs_lutime = a.wrap(vim.loop.fs_lutime),
	fs_mkdir = a.wrap(vim.loop.fs_mkdir),
	fs_mkdtemp = a.wrap(vim.loop.fs_mkdtemp),
	fs_mkstemp = a.wrap(vim.loop.fs_mkstemp),
	fs_open = a.wrap(vim.loop.fs_open),
	fs_opendir = a.wrap(vim.loop.fs_opendir),
	fs_poll_getpath = vim.loop.fs_poll_getpath,
	fs_poll_start = a.wrap(vim.loop.fs_poll_start),
	fs_poll_stop = vim.loop.fs_poll_stop,
	fs_read = a.wrap(vim.loop.fs_read),
	fs_readdir = a.wrap(vim.loop.fs_readdir),
	fs_readlink = a.wrap(vim.loop.fs_readlink),
	fs_realpath = a.wrap(vim.loop.fs_realpath),
	fs_rename = a.wrap(vim.loop.fs_rename),
	fs_rmdir = a.wrap(vim.loop.fs_rmdir),
	fs_scandir = a.wrap(vim.loop.fs_scandir),
	fs_scandir_next = vim.loop.fs_scandir_next,
	fs_sendfile = a.wrap(vim.loop.fs_sendfile),
	fs_stat = a.wrap(vim.loop.fs_stat),
	fs_statfs = a.wrap(vim.loop.fs_statfs),
	fs_symlink = a.wrap(vim.loop.fs_symlink),
	fs_unlink = a.wrap(vim.loop.fs_unlink),
	fs_utime = a.wrap(vim.loop.fs_utime),
	fs_write = a.wrap(vim.loop.fs_write),
	get_constrained_memory = vim.loop.get_constrained_memory,
	get_free_memory = vim.loop.get_free_memory,
	get_process_title = vim.loop.get_process_title,
	get_total_memory = vim.loop.get_total_memory,
	getaddrinfo = a.wrap(vim.loop.getaddrinfo),
	getgid = vim.loop.getgid,
	getnameinfo = a.wrap(vim.loop.getnameinfo),
	getpid = vim.loop.getpid,
	getrusage = vim.loop.getrusage,
	gettimeofday = vim.loop.gettimeofday,
	getuid = vim.loop.getuid,
	guess_handle = vim.loop.guess_handle,
	handle_get_type = vim.loop.handle_get_type,
	has_ref = vim.loop.has_ref,
	hrtime = vim.loop.hrtime,
	idle_start = a.wrap(vim.loop.idle_start),
	idle_stop = vim.loop.idle_stop,
	if_indextoiid = vim.loop.if_indextoiid,
	if_indextoname = vim.loop.if_indextoname,
	interface_addresses = vim.loop.interface_addresses,
	is_active = vim.loop.is_active,
	is_closing = vim.loop.is_closing,
	is_readable = vim.loop.is_readable,
	is_writable = vim.loop.is_writable,
	kill = vim.loop.kill,
	listen = a.wrap(vim.loop.listen),
	loadavg = vim.loop.loadavg,
	loop_alive = vim.loop.loop_alive,
	loop_close = vim.loop.loop_close,
	loop_configure = vim.loop.loop_configure,
	loop_mode = vim.loop.loop_mode,
	metrics_idle_time = vim.loop.metrics_idle_time,
	new_async = a.wrap(vim.loop.new_async),
	new_check = vim.loop.new_check,
	new_fs_event = vim.loop.new_fs_event,
	new_fs_poll = vim.loop.new_fs_poll,
	new_idle = vim.loop.new_idle,
	new_pipe = vim.loop.new_pipe,
	new_poll = vim.loop.new_poll,
	new_prepare = vim.loop.new_prepare,
	new_signal = vim.loop.new_signal,
	new_socket_poll = vim.loop.new_socket_poll,
	new_tcp = vim.loop.new_tcp,
	new_thread = vim.loop.new_thread,
	new_timer = vim.loop.new_timer,
	new_tty = vim.loop.new_tty,
	new_udp = vim.loop.new_udp,
	new_work = a.wrap(vim.loop.new_work),
	now = vim.loop.now,
	os_environ = vim.loop.os_environ,
	os_get_passwd = vim.loop.os_get_passwd,
	os_getenv = vim.loop.os_getenv,
	os_gethostname = vim.loop.os_gethostname,
	os_getpid = vim.loop.os_getpid,
	os_getppid = vim.loop.os_getppid,
	os_getpriority = vim.loop.os_getpriority,
	os_homedir = vim.loop.os_homedir,
	os_setenv = vim.loop.os_setenv,
	os_setpriority = vim.loop.os_setpriority,
	os_tmpdir = vim.loop.os_tmpdir,
	os_uname = vim.loop.os_uname,
	os_unsetenv = vim.loop.os_unsetenv,
	pipe = vim.loop.pipe,
	pipe_bind = vim.loop.pipe_bind,
	pipe_chmod = vim.loop.pipe_chmod,
	pipe_connect = a.wrap(vim.loop.pipe_connect),
	pipe_getpeername = vim.loop.pipe_getpeername,
	pipe_getsockname = vim.loop.pipe_getsockname,
	pipe_open = vim.loop.pipe_open,
	pipe_pending_count = vim.loop.pipe_pending_count,
	pipe_pending_instances = vim.loop.pipe_pending_instances,
	pipe_pending_type = vim.loop.pipe_pending_type,
	poll_start = a.wrap(vim.loop.poll_start),
	poll_stop = vim.loop.poll_stop,
	prepare_start = a.wrap(vim.loop.prepare_start),
	prepare_stop = vim.loop.prepare_stop,
	print_active_handles = vim.loop.print_active_handles,
	print_all_handles = vim.loop.print_all_handles,
	process_get_pid = vim.loop.process_get_pid,
	process_kill = vim.loop.process_kill,
	queue_work = vim.loop.queue_work,
	random = a.wrap(vim.loop.random),
	read_start = a.wrap(vim.loop.read_start),
	read_stop = vim.loop.read_stop,
	recv_buffer_size = vim.loop.recv_buffer_size,
	ref = vim.loop.ref,
	req_get_type = vim.loop.req_get_type,
	resident_set_memory = vim.loop.resident_set_memory,
	run = vim.loop.run,
	send_buffer_size = vim.loop.send_buffer_size,
	set_process_title = vim.loop.set_process_title,
	setgid = vim.loop.setgid,
	setuid = vim.loop.setuid,
	shutdown = a.wrap(vim.loop.shutdown),
	signal_start = a.wrap(vim.loop.signal_start),
	signal_start_oneshot = a.wrap(vim.loop.signal_start_oneshot),
	signal_stop = vim.loop.signal_stop,
	sleep = vim.loop.sleep,
	socketpair = vim.loop.socketpair,
	spawn = vim.loop.spawn,
	stop = vim.loop.stop,
	stream_get_write_queue_size = vim.loop.stream_get_write_queue_size,
	stream_set_blocking = vim.loop.stream_set_blocking,
	tcp_bind = vim.loop.tcp_bind,
	tcp_close_reset = a.wrap(vim.loop.tcp_close_reset),
	tcp_connect = a.wrap(vim.loop.tcp_connect),
	tcp_getpeername = vim.loop.tcp_getpeername,
	tcp_getsockname = vim.loop.tcp_getsockname,
	tcp_keepalive = vim.loop.tcp_keepalive,
	tcp_nodelay = vim.loop.tcp_nodelay,
	tcp_open = vim.loop.tcp_open,
	tcp_simultaneous_accepts = vim.loop.tcp_simultaneous_accepts,
	tcp_write_queue_size = vim.loop.tcp_write_queue_size,
	thread_equal = vim.loop.thread_equal,
	thread_join = vim.loop.thread_join,
	thread_self = vim.loop.thread_self,
	timer_again = vim.loop.timer_again,
	timer_get_due_in = vim.loop.timer_get_due_in,
	timer_get_repeat = vim.loop.timer_get_repeat,
	timer_set_repeat = vim.loop.timer_set_repeat,
	timer_start = a.wrap(vim.loop.timer_start),
	timer_stop = vim.loop.timer_stop,
	translate_sys_error = vim.loop.translate_sys_error,
	try_write = vim.loop.try_write,
	try_write2 = vim.loop.try_write2,
	tty_get_vterm_state = vim.loop.tty_get_vterm_state,
	tty_get_winsize = vim.loop.tty_get_winsize,
	tty_reset_mode = vim.loop.tty_reset_mode,
	tty_set_mode = vim.loop.tty_set_mode,
	tty_set_vterm_state = vim.loop.tty_set_vterm_state,
	udp_bind = vim.loop.udp_bind,
	udp_connect = vim.loop.udp_connect,
	udp_get_send_queue_count = vim.loop.udp_get_send_queue_count,
	udp_get_send_queue_size = vim.loop.udp_get_send_queue_size,
	udp_getpeername = vim.loop.udp_getpeername,
	udp_getsockname = vim.loop.udp_getsockname,
	udp_open = vim.loop.udp_open,
	udp_recv_start = a.wrap(vim.loop.udp_recv_start),
	udp_recv_stop = vim.loop.udp_recv_stop,
	udp_send = a.wrap(vim.loop.udp_send),
	udp_set_broadcast = vim.loop.udp_set_broadcast,
	udp_set_membership = vim.loop.udp_set_membership,
	udp_set_multicast_interface = vim.loop.udp_set_multicast_interface,
	udp_set_multicast_loop = vim.loop.udp_set_multicast_loop,
	udp_set_multicast_ttl = vim.loop.udp_set_multicast_ttl,
	udp_set_source_membership = vim.loop.udp_set_source_membership,
	udp_set_ttl = vim.loop.udp_set_ttl,
	udp_try_send = vim.loop.udp_try_send,
	unref = vim.loop.unref,
	update_time = vim.loop.update_time,
	uptime = vim.loop.uptime,
	version = vim.loop.version,
	version_string = vim.loop.version_string,
	walk = a.wrap(vim.loop.walk),
	write = a.wrap(vim.loop.write),
	write2 = a.wrap(vim.loop.write2),
}
